## K-means


**算法描述：**

* 任选K个点作为初始聚类中心
* 根据每个聚类的中心，计算每个对象与这些中心的距离，并根据最小距离重新对对象进行划分
* 重新计算每个聚类的中心（质心实际上不存在的）
* 当满足一定条件，如类别划分不在发生变化时，算法终止，否则继续2-3


![](https://i.imgur.com/6Zdir1p.png)
![](https://i.imgur.com/3XPw8g7.png)
![](https://i.imgur.com/AhLBZqA.png)

**时间复杂度：**
>O(nkt)

* n->聚类对象数
* t->迭代次数
* k->初始中心个数

**平面划分**
>两点之间的垂直平分线,迭代划分。

![](https://i.imgur.com/tQVzJJQ.png)

![](https://i.imgur.com/v8dbhoe.png)

**欧式距离**


对于欧式空间的样本数据，以平方误差和（sum of the squared error, SSE)作为聚类的目标函数，同时也可以衡量不同聚类结果好坏的指标：

![](https://i.imgur.com/mXaB1Ic.png)

表示样本点x到cluster Ci 的质心 ci 距离平方和；最优的聚类结果应使得SSE达到最小值。

![](https://i.imgur.com/qcrsI6V.png)


**重新计算每个聚类的中心对象**

中心对象：均值

**终止条件**

>最小化蔟内对象到质心的距离，从而最小化WCSS。通过损失函数来衡量算法停止条件。

* 损失函数：WCSS

![](https://i.imgur.com/xDt54Q7.png)

xi代表某个样本点，ck代表每个类的中心点。每个类里的元素越凝聚越好。

**中心点选择**

* K（类别）的选择 细粒度 越多越准确 
* 随机选取
* 多次随机：选择最小的WCSS那次聚类

**优点**

* 算法简单有效
* 时间复杂度可控

**缺点**

* 受质心影响大
* K值选取会直接影响聚类结果

**使用场景**

* 样本球形分布
* 密度，大小不同的聚类

